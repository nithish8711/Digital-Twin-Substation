"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/resources/page",{

/***/ "(app-pages-browser)/./components/course/course-context.tsx":
/*!**********************************************!*\
  !*** ./components/course/course-context.tsx ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CourseProvider: () => (/* binding */ CourseProvider),\n/* harmony export */   useCourse: () => (/* binding */ useCourse)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ CourseProvider,useCourse auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst CourseContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst STORAGE_KEY = \"course-progress\";\nfunction loadProgressFromStorage() {\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(STORAGE_KEY);\n        if (stored) {\n            const parsed = JSON.parse(stored);\n            // Validate and merge with initial progress\n            const initial = getInitialProgress();\n            const merged = {\n                ...initial\n            };\n            Object.keys(parsed).forEach((key)=>{\n                if (key in initial) {\n                    merged[key] = {\n                        ...initial[key],\n                        ...parsed[key],\n                        componentId: key\n                    };\n                }\n            });\n            return merged;\n        }\n    } catch (error) {\n        console.error(\"Failed to load course progress:\", error);\n    }\n    return getInitialProgress();\n}\nfunction getInitialProgress() {\n    return {\n        transformer: {\n            componentId: \"transformer\",\n            status: \"notStarted\",\n            videos: [],\n            quizAttempts: 0,\n            quizPassed: false\n        },\n        bayLines: {\n            componentId: \"bayLines\",\n            status: \"notStarted\",\n            videos: [],\n            quizAttempts: 0,\n            quizPassed: false\n        },\n        isolator: {\n            componentId: \"isolator\",\n            status: \"notStarted\",\n            videos: [],\n            quizAttempts: 0,\n            quizPassed: false\n        },\n        circuitBreaker: {\n            componentId: \"circuitBreaker\",\n            status: \"notStarted\",\n            videos: [],\n            quizAttempts: 0,\n            quizPassed: false\n        }\n    };\n}\nfunction saveProgressToStorage(progress) {\n    if (false) {}\n    try {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));\n    } catch (error) {\n        console.error(\"Failed to save course progress:\", error);\n    }\n}\nfunction CourseProvider({ children }) {\n    _s();\n    const [progress, setProgress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"CourseProvider.useState\": ()=>loadProgressFromStorage()\n    }[\"CourseProvider.useState\"]);\n    // Save to localStorage whenever progress changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CourseProvider.useEffect\": ()=>{\n            saveProgressToStorage(progress);\n        }\n    }[\"CourseProvider.useEffect\"], [\n        progress\n    ]);\n    const updateVideoProgress = (componentId, videoId, progressValue)=>{\n        setProgress((prev)=>{\n            const component = {\n                ...prev[componentId]\n            };\n            const videoIndex = component.videos.findIndex((v)=>v.videoId === videoId);\n            if (videoIndex >= 0) {\n                component.videos[videoIndex] = {\n                    ...component.videos[videoIndex],\n                    progress: progressValue\n                };\n            } else {\n                component.videos.push({\n                    videoId,\n                    watched: false,\n                    progress: progressValue\n                });\n            }\n            // Update status\n            if (progressValue > 0 && component.status === \"notStarted\") {\n                component.status = \"inProgress\";\n            }\n            return {\n                ...prev,\n                [componentId]: component\n            };\n        });\n    };\n    const markVideoComplete = (componentId, videoId)=>{\n        setProgress((prev)=>{\n            const component = {\n                ...prev[componentId]\n            };\n            const videoIndex = component.videos.findIndex((v)=>v.videoId === videoId);\n            if (videoIndex >= 0) {\n                component.videos[videoIndex] = {\n                    ...component.videos[videoIndex],\n                    watched: true,\n                    progress: 100,\n                    completedAt: Date.now()\n                };\n            } else {\n                component.videos.push({\n                    videoId,\n                    watched: true,\n                    progress: 100,\n                    completedAt: Date.now()\n                });\n            }\n            // Check if all videos are complete\n            // Note: We'll need to import courseData to check total videos\n            // For now, we'll update status based on completion\n            return {\n                ...prev,\n                [componentId]: component\n            };\n        });\n    };\n    const submitQuiz = (componentId, score, passed)=>{\n        setProgress((prev)=>{\n            const component = {\n                ...prev[componentId]\n            };\n            component.quizAttempts += 1;\n            component.quizScore = score;\n            if (passed) {\n                component.quizPassed = true;\n                component.quizPassedAt = Date.now();\n                component.status = \"completed\";\n            }\n            return {\n                ...prev,\n                [componentId]: component\n            };\n        });\n    };\n    const isSimulationUnlocked = ()=>{\n        // User must pass all component quizzes to unlock simulation\n        return Object.values(progress).every((comp)=>comp.quizPassed);\n    };\n    const getOverallProgress = ()=>{\n        const totalComponents = Object.keys(progress).length;\n        const completedComponents = Object.values(progress).filter((comp)=>comp.status === \"completed\").length;\n        return totalComponents > 0 ? Math.round(completedComponents / totalComponents * 100) : 0;\n    };\n    const resetProgress = ()=>{\n        const initial = getInitialProgress();\n        setProgress(initial);\n        if (true) {\n            localStorage.removeItem(STORAGE_KEY);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CourseContext.Provider, {\n        value: {\n            progress,\n            updateVideoProgress,\n            markVideoComplete,\n            submitQuiz,\n            isSimulationUnlocked,\n            getOverallProgress,\n            resetProgress\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Projects\\\\Digital-Twin-Substation\\\\components\\\\course\\\\course-context.tsx\",\n        lineNumber: 225,\n        columnNumber: 5\n    }, this);\n}\n_s(CourseProvider, \"JNpzuF9EtMSSVXS0seEm/JGgDYI=\");\n_c = CourseProvider;\nfunction useCourse() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(CourseContext);\n    if (!context) {\n        throw new Error(\"useCourse must be used within CourseProvider\");\n    }\n    return context;\n}\n_s1(useCourse, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"CourseProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvY291cnNlL2NvdXJzZS1jb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRWlGO0FBZ0NqRixNQUFNSSw4QkFBZ0JKLG9EQUFhQSxDQUFnQ0s7QUFFbkUsTUFBTUMsY0FBYztBQUVwQixTQUFTQztJQUNQLElBQUksS0FBNkIsRUFBRSxFQUVsQztJQUVELElBQUk7UUFDRixNQUFNRSxTQUFTQyxhQUFhQyxPQUFPLENBQUNMO1FBQ3BDLElBQUlHLFFBQVE7WUFDVixNQUFNRyxTQUFTQyxLQUFLQyxLQUFLLENBQUNMO1lBQzFCLDJDQUEyQztZQUMzQyxNQUFNTSxVQUFVUDtZQUNoQixNQUFNUSxTQUFtRDtnQkFBRSxHQUFHRCxPQUFPO1lBQUM7WUFFdEVFLE9BQU9DLElBQUksQ0FBQ04sUUFBUU8sT0FBTyxDQUFDLENBQUNDO2dCQUMzQixJQUFJQSxPQUFPTCxTQUFTO29CQUNsQkMsTUFBTSxDQUFDSSxJQUFxQixHQUFHO3dCQUM3QixHQUFHTCxPQUFPLENBQUNLLElBQXFCO3dCQUNoQyxHQUFHUixNQUFNLENBQUNRLElBQUk7d0JBQ2RDLGFBQWFEO29CQUNmO2dCQUNGO1lBQ0Y7WUFFQSxPQUFPSjtRQUNUO0lBQ0YsRUFBRSxPQUFPTSxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxtQ0FBbUNBO0lBQ25EO0lBRUEsT0FBT2Q7QUFDVDtBQUVBLFNBQVNBO0lBQ1AsT0FBTztRQUNMZ0IsYUFBYTtZQUNYSCxhQUFhO1lBQ2JJLFFBQVE7WUFDUkMsUUFBUSxFQUFFO1lBQ1ZDLGNBQWM7WUFDZEMsWUFBWTtRQUNkO1FBQ0FDLFVBQVU7WUFDUlIsYUFBYTtZQUNiSSxRQUFRO1lBQ1JDLFFBQVEsRUFBRTtZQUNWQyxjQUFjO1lBQ2RDLFlBQVk7UUFDZDtRQUNBRSxVQUFVO1lBQ1JULGFBQWE7WUFDYkksUUFBUTtZQUNSQyxRQUFRLEVBQUU7WUFDVkMsY0FBYztZQUNkQyxZQUFZO1FBQ2Q7UUFDQUcs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R2lCLElBQUk7Z0JBQ1AsQ0FBQ3JCLFlBQVksRUFBRXNCO1lBQ2pCO1FBQ0Y7SUFDRjtJQUVBLE1BQU1lLHVCQUF1QjtRQUMzQiw0REFBNEQ7UUFDNUQsT0FBT3pDLE9BQU8wQyxNQUFNLENBQUMxQixVQUFVMkIsS0FBSyxDQUFDLENBQUNDLE9BQVNBLEtBQUtqQyxVQUFVO0lBQ2hFO0lBRUEsTUFBTWtDLHFCQUFxQjtRQUN6QixNQUFNQyxrQkFBa0I5QyxPQUFPQyxJQUFJLENBQUNlLFVBQVUrQixNQUFNO1FBQ3BELE1BQU1DLHNCQUFzQmhELE9BQU8wQyxNQUFNLENBQUMxQixVQUFVaUMsTUFBTSxDQUFDLENBQUNMLE9BQVNBLEtBQUtwQyxNQUFNLEtBQUssYUFBYXVDLE1BQU07UUFDeEcsT0FBT0Qsa0JBQWtCLElBQUlJLEtBQUtDLEtBQUssQ0FBQyxzQkFBdUJMLGtCQUFtQixPQUFPO0lBQzNGO0lBRUEsTUFBTU0sZ0JBQWdCO1FBQ3BCLE1BQU10RCxVQUFVUDtRQUNoQjhCLFlBQVl2QjtRQUNaLElBQUksSUFBNkIsRUFBRTtZQUNqQ0wsYUFBYTRELFVBQVUsQ0FBQ2hFO1FBQzFCO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ0YsY0FBY21FLFFBQVE7UUFDckJDLE9BQU87WUFDTHZDO1lBQ0FNO1lBQ0FVO1lBQ0FJO1lBQ0FLO1lBQ0FJO1lBQ0FPO1FBQ0Y7a0JBRUNoQzs7Ozs7O0FBR1A7R0E3SGdCRDtLQUFBQTtBQStIVCxTQUFTcUM7O0lBQ2QsTUFBTUMsVUFBVXpFLGlEQUFVQSxDQUFDRztJQUMzQixJQUFJLENBQUNzRSxTQUFTO1FBQ1osTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Q7QUFDVDtJQU5nQkQiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcRGlnaXRhbC1Ud2luLVN1YnN0YXRpb25cXGNvbXBvbmVudHNcXGNvdXJzZVxcY291cnNlLWNvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXHJcblxyXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCBSZWFjdE5vZGUgfSBmcm9tIFwicmVhY3RcIlxyXG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudFR5cGUgfSBmcm9tIFwiQC9saWIvY291cnNlLWRhdGFcIlxyXG5cclxuZXhwb3J0IHR5cGUgUHJvZ3Jlc3NTdGF0dXMgPSBcIm5vdFN0YXJ0ZWRcIiB8IFwiaW5Qcm9ncmVzc1wiIHwgXCJjb21wbGV0ZWRcIlxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWaWRlb1Byb2dyZXNzIHtcclxuICB2aWRlb0lkOiBzdHJpbmdcclxuICB3YXRjaGVkOiBib29sZWFuXHJcbiAgcHJvZ3Jlc3M6IG51bWJlciAvLyAwLTEwMFxyXG4gIGNvbXBsZXRlZEF0PzogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50UHJvZ3Jlc3Mge1xyXG4gIGNvbXBvbmVudElkOiBDb21wb25lbnRUeXBlXHJcbiAgc3RhdHVzOiBQcm9ncmVzc1N0YXR1c1xyXG4gIHZpZGVvczogVmlkZW9Qcm9ncmVzc1tdXHJcbiAgcXVpekF0dGVtcHRzOiBudW1iZXJcclxuICBxdWl6UGFzc2VkOiBib29sZWFuXHJcbiAgcXVpelNjb3JlPzogbnVtYmVyXHJcbiAgcXVpelBhc3NlZEF0PzogbnVtYmVyXHJcbn1cclxuXHJcbmludGVyZmFjZSBDb3Vyc2VDb250ZXh0VHlwZSB7XHJcbiAgcHJvZ3Jlc3M6IFJlY29yZDxDb21wb25lbnRUeXBlLCBDb21wb25lbnRQcm9ncmVzcz5cclxuICB1cGRhdGVWaWRlb1Byb2dyZXNzOiAoY29tcG9uZW50SWQ6IENvbXBvbmVudFR5cGUsIHZpZGVvSWQ6IHN0cmluZywgcHJvZ3Jlc3M6IG51bWJlcikgPT4gdm9pZFxyXG4gIG1hcmtWaWRlb0NvbXBsZXRlOiAoY29tcG9uZW50SWQ6IENvbXBvbmVudFR5cGUsIHZpZGVvSWQ6IHN0cmluZykgPT4gdm9pZFxyXG4gIHN1Ym1pdFF1aXo6IChjb21wb25lbnRJZDogQ29tcG9uZW50VHlwZSwgc2NvcmU6IG51bWJlciwgcGFzc2VkOiBib29sZWFuKSA9PiB2b2lkXHJcbiAgaXNTaW11bGF0aW9uVW5sb2NrZWQ6ICgpID0+IGJvb2xlYW5cclxuICBnZXRPdmVyYWxsUHJvZ3Jlc3M6ICgpID0+IG51bWJlclxyXG4gIHJlc2V0UHJvZ3Jlc3M6ICgpID0+IHZvaWRcclxufVxyXG5cclxuY29uc3QgQ291cnNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Q291cnNlQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZClcclxuXHJcbmNvbnN0IFNUT1JBR0VfS0VZID0gXCJjb3Vyc2UtcHJvZ3Jlc3NcIlxyXG5cclxuZnVuY3Rpb24gbG9hZFByb2dyZXNzRnJvbVN0b3JhZ2UoKTogUmVjb3JkPENvbXBvbmVudFR5cGUsIENvbXBvbmVudFByb2dyZXNzPiB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHJldHVybiBnZXRJbml0aWFsUHJvZ3Jlc3MoKVxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZKVxyXG4gICAgaWYgKHN0b3JlZCkge1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHN0b3JlZClcclxuICAgICAgLy8gVmFsaWRhdGUgYW5kIG1lcmdlIHdpdGggaW5pdGlhbCBwcm9ncmVzc1xyXG4gICAgICBjb25zdCBpbml0aWFsID0gZ2V0SW5pdGlhbFByb2dyZXNzKClcclxuICAgICAgY29uc3QgbWVyZ2VkOiBSZWNvcmQ8Q29tcG9uZW50VHlwZSwgQ29tcG9uZW50UHJvZ3Jlc3M+ID0geyAuLi5pbml0aWFsIH1cclxuXHJcbiAgICAgIE9iamVjdC5rZXlzKHBhcnNlZCkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgaWYgKGtleSBpbiBpbml0aWFsKSB7XHJcbiAgICAgICAgICBtZXJnZWRba2V5IGFzIENvbXBvbmVudFR5cGVdID0ge1xyXG4gICAgICAgICAgICAuLi5pbml0aWFsW2tleSBhcyBDb21wb25lbnRUeXBlXSxcclxuICAgICAgICAgICAgLi4ucGFyc2VkW2tleV0sXHJcbiAgICAgICAgICAgIGNvbXBvbmVudElkOiBrZXkgYXMgQ29tcG9uZW50VHlwZSxcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcblxyXG4gICAgICByZXR1cm4gbWVyZ2VkXHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBjb3Vyc2UgcHJvZ3Jlc3M6XCIsIGVycm9yKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGdldEluaXRpYWxQcm9ncmVzcygpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEluaXRpYWxQcm9ncmVzcygpOiBSZWNvcmQ8Q29tcG9uZW50VHlwZSwgQ29tcG9uZW50UHJvZ3Jlc3M+IHtcclxuICByZXR1cm4ge1xyXG4gICAgdHJhbnNmb3JtZXI6IHtcclxuICAgICAgY29tcG9uZW50SWQ6IFwidHJhbnNmb3JtZXJcIixcclxuICAgICAgc3RhdHVzOiBcIm5vdFN0YXJ0ZWRcIixcclxuICAgICAgdmlkZW9zOiBbXSxcclxuICAgICAgcXVpekF0dGVtcHRzOiAwLFxyXG4gICAgICBxdWl6UGFzc2VkOiBmYWxzZSxcclxuICAgIH0sXHJcbiAgICBiYXlMaW5lczoge1xyXG4gICAgICBjb21wb25lbnRJZDogXCJiYXlMaW5lc1wiLFxyXG4gICAgICBzdGF0dXM6IFwibm90U3RhcnRlZFwiLFxyXG4gICAgICB2aWRlb3M6IFtdLFxyXG4gICAgICBxdWl6QXR0ZW1wdHM6IDAsXHJcbiAgICAgIHF1aXpQYXNzZWQ6IGZhbHNlLFxyXG4gICAgfSxcclxuICAgIGlzb2xhdG9yOiB7XHJcbiAgICAgIGNvbXBvbmVudElkOiBcImlzb2xhdG9yXCIsXHJcbiAgICAgIHN0YXR1czogXCJub3RTdGFydGVkXCIsXHJcbiAgICAgIHZpZGVvczogW10sXHJcbiAgICAgIHF1aXpBdHRlbXB0czogMCxcclxuICAgICAgcXVpelBhc3NlZDogZmFsc2UsXHJcbiAgICB9LFxyXG4gICAgY2lyY3VpdEJyZWFrZXI6IHtcclxuICAgICAgY29tcG9uZW50SWQ6IFwiY2lyY3VpdEJyZWFrZXJcIixcclxuICAgICAgc3RhdHVzOiBcIm5vdFN0YXJ0ZWRcIixcclxuICAgICAgdmlkZW9zOiBbXSxcclxuICAgICAgcXVpekF0dGVtcHRzOiAwLFxyXG4gICAgICBxdWl6UGFzc2VkOiBmYWxzZSxcclxuICAgIH0sXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzYXZlUHJvZ3Jlc3NUb1N0b3JhZ2UocHJvZ3Jlc3M6IFJlY29yZDxDb21wb25lbnRUeXBlLCBDb21wb25lbnRQcm9ncmVzcz4pIHtcclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXHJcblxyXG4gIHRyeSB7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkocHJvZ3Jlc3MpKVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNhdmUgY291cnNlIHByb2dyZXNzOlwiLCBlcnJvcilcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDb3Vyc2VQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XHJcbiAgY29uc3QgW3Byb2dyZXNzLCBzZXRQcm9ncmVzc10gPSB1c2VTdGF0ZTxSZWNvcmQ8Q29tcG9uZW50VHlwZSwgQ29tcG9uZW50UHJvZ3Jlc3M+PigoKSA9PlxyXG4gICAgbG9hZFByb2dyZXNzRnJvbVN0b3JhZ2UoKVxyXG4gIClcclxuXHJcbiAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2Ugd2hlbmV2ZXIgcHJvZ3Jlc3MgY2hhbmdlc1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBzYXZlUHJvZ3Jlc3NUb1N0b3JhZ2UocHJvZ3Jlc3MpXHJcbiAgfSwgW3Byb2dyZXNzXSlcclxuXHJcbiAgY29uc3QgdXBkYXRlVmlkZW9Qcm9ncmVzcyA9IChjb21wb25lbnRJZDogQ29tcG9uZW50VHlwZSwgdmlkZW9JZDogc3RyaW5nLCBwcm9ncmVzc1ZhbHVlOiBudW1iZXIpID0+IHtcclxuICAgIHNldFByb2dyZXNzKChwcmV2KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHsgLi4ucHJldltjb21wb25lbnRJZF0gfVxyXG4gICAgICBjb25zdCB2aWRlb0luZGV4ID0gY29tcG9uZW50LnZpZGVvcy5maW5kSW5kZXgoKHYpID0+IHYudmlkZW9JZCA9PT0gdmlkZW9JZClcclxuXHJcbiAgICAgIGlmICh2aWRlb0luZGV4ID49IDApIHtcclxuICAgICAgICBjb21wb25lbnQudmlkZW9zW3ZpZGVvSW5kZXhdID0ge1xyXG4gICAgICAgICAgLi4uY29tcG9uZW50LnZpZGVvc1t2aWRlb0luZGV4XSxcclxuICAgICAgICAgIHByb2dyZXNzOiBwcm9ncmVzc1ZhbHVlLFxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb21wb25lbnQudmlkZW9zLnB1c2goe1xyXG4gICAgICAgICAgdmlkZW9JZCxcclxuICAgICAgICAgIHdhdGNoZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzVmFsdWUsXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBkYXRlIHN0YXR1c1xyXG4gICAgICBpZiAocHJvZ3Jlc3NWYWx1ZSA+IDAgJiYgY29tcG9uZW50LnN0YXR1cyA9PT0gXCJub3RTdGFydGVkXCIpIHtcclxuICAgICAgICBjb21wb25lbnQuc3RhdHVzID0gXCJpblByb2dyZXNzXCJcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5wcmV2LFxyXG4gICAgICAgIFtjb21wb25lbnRJZF06IGNvbXBvbmVudCxcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGNvbnN0IG1hcmtWaWRlb0NvbXBsZXRlID0gKGNvbXBvbmVudElkOiBDb21wb25lbnRUeXBlLCB2aWRlb0lkOiBzdHJpbmcpID0+IHtcclxuICAgIHNldFByb2dyZXNzKChwcmV2KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHsgLi4ucHJldltjb21wb25lbnRJZF0gfVxyXG4gICAgICBjb25zdCB2aWRlb0luZGV4ID0gY29tcG9uZW50LnZpZGVvcy5maW5kSW5kZXgoKHYpID0+IHYudmlkZW9JZCA9PT0gdmlkZW9JZClcclxuXHJcbiAgICAgIGlmICh2aWRlb0luZGV4ID49IDApIHtcclxuICAgICAgICBjb21wb25lbnQudmlkZW9zW3ZpZGVvSW5kZXhdID0ge1xyXG4gICAgICAgICAgLi4uY29tcG9uZW50LnZpZGVvc1t2aWRlb0luZGV4XSxcclxuICAgICAgICAgIHdhdGNoZWQ6IHRydWUsXHJcbiAgICAgICAgICBwcm9ncmVzczogMTAwLFxyXG4gICAgICAgICAgY29tcGxldGVkQXQ6IERhdGUubm93KCksXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbXBvbmVudC52aWRlb3MucHVzaCh7XHJcbiAgICAgICAgICB2aWRlb0lkLFxyXG4gICAgICAgICAgd2F0Y2hlZDogdHJ1ZSxcclxuICAgICAgICAgIHByb2dyZXNzOiAxMDAsXHJcbiAgICAgICAgICBjb21wbGV0ZWRBdDogRGF0ZS5ub3coKSxcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBhbGwgdmlkZW9zIGFyZSBjb21wbGV0ZVxyXG4gICAgICAvLyBOb3RlOiBXZSdsbCBuZWVkIHRvIGltcG9ydCBjb3Vyc2VEYXRhIHRvIGNoZWNrIHRvdGFsIHZpZGVvc1xyXG4gICAgICAvLyBGb3Igbm93LCB3ZSdsbCB1cGRhdGUgc3RhdHVzIGJhc2VkIG9uIGNvbXBsZXRpb25cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4ucHJldixcclxuICAgICAgICBbY29tcG9uZW50SWRdOiBjb21wb25lbnQsXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICBjb25zdCBzdWJtaXRRdWl6ID0gKGNvbXBvbmVudElkOiBDb21wb25lbnRUeXBlLCBzY29yZTogbnVtYmVyLCBwYXNzZWQ6IGJvb2xlYW4pID0+IHtcclxuICAgIHNldFByb2dyZXNzKChwcmV2KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHsgLi4ucHJldltjb21wb25lbnRJZF0gfVxyXG4gICAgICBjb21wb25lbnQucXVpekF0dGVtcHRzICs9IDFcclxuICAgICAgY29tcG9uZW50LnF1aXpTY29yZSA9IHNjb3JlXHJcblxyXG4gICAgICBpZiAocGFzc2VkKSB7XHJcbiAgICAgICAgY29tcG9uZW50LnF1aXpQYXNzZWQgPSB0cnVlXHJcbiAgICAgICAgY29tcG9uZW50LnF1aXpQYXNzZWRBdCA9IERhdGUubm93KClcclxuICAgICAgICBjb21wb25lbnQuc3RhdHVzID0gXCJjb21wbGV0ZWRcIlxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLnByZXYsXHJcbiAgICAgICAgW2NvbXBvbmVudElkXTogY29tcG9uZW50LFxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaXNTaW11bGF0aW9uVW5sb2NrZWQgPSAoKTogYm9vbGVhbiA9PiB7XHJcbiAgICAvLyBVc2VyIG11c3QgcGFzcyBhbGwgY29tcG9uZW50IHF1aXp6ZXMgdG8gdW5sb2NrIHNpbXVsYXRpb25cclxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHByb2dyZXNzKS5ldmVyeSgoY29tcCkgPT4gY29tcC5xdWl6UGFzc2VkKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgZ2V0T3ZlcmFsbFByb2dyZXNzID0gKCk6IG51bWJlciA9PiB7XHJcbiAgICBjb25zdCB0b3RhbENvbXBvbmVudHMgPSBPYmplY3Qua2V5cyhwcm9ncmVzcykubGVuZ3RoXHJcbiAgICBjb25zdCBjb21wbGV0ZWRDb21wb25lbnRzID0gT2JqZWN0LnZhbHVlcyhwcm9ncmVzcykuZmlsdGVyKChjb21wKSA9PiBjb21wLnN0YXR1cyA9PT0gXCJjb21wbGV0ZWRcIikubGVuZ3RoXHJcbiAgICByZXR1cm4gdG90YWxDb21wb25lbnRzID4gMCA/IE1hdGgucm91bmQoKGNvbXBsZXRlZENvbXBvbmVudHMgLyB0b3RhbENvbXBvbmVudHMpICogMTAwKSA6IDBcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlc2V0UHJvZ3Jlc3MgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBpbml0aWFsID0gZ2V0SW5pdGlhbFByb2dyZXNzKClcclxuICAgIHNldFByb2dyZXNzKGluaXRpYWwpXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX0tFWSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8Q291cnNlQ29udGV4dC5Qcm92aWRlclxyXG4gICAgICB2YWx1ZT17e1xyXG4gICAgICAgIHByb2dyZXNzLFxyXG4gICAgICAgIHVwZGF0ZVZpZGVvUHJvZ3Jlc3MsXHJcbiAgICAgICAgbWFya1ZpZGVvQ29tcGxldGUsXHJcbiAgICAgICAgc3VibWl0UXVpeixcclxuICAgICAgICBpc1NpbXVsYXRpb25VbmxvY2tlZCxcclxuICAgICAgICBnZXRPdmVyYWxsUHJvZ3Jlc3MsXHJcbiAgICAgICAgcmVzZXRQcm9ncmVzcyxcclxuICAgICAgfX1cclxuICAgID5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9Db3Vyc2VDb250ZXh0LlByb3ZpZGVyPlxyXG4gIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvdXJzZSgpIHtcclxuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChDb3Vyc2VDb250ZXh0KVxyXG4gIGlmICghY29udGV4dCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlQ291cnNlIG11c3QgYmUgdXNlZCB3aXRoaW4gQ291cnNlUHJvdmlkZXJcIilcclxuICB9XHJcbiAgcmV0dXJuIGNvbnRleHRcclxufVxyXG5cclxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJDb3Vyc2VDb250ZXh0IiwidW5kZWZpbmVkIiwiU1RPUkFHRV9LRVkiLCJsb2FkUHJvZ3Jlc3NGcm9tU3RvcmFnZSIsImdldEluaXRpYWxQcm9ncmVzcyIsInN0b3JlZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJpbml0aWFsIiwibWVyZ2VkIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJjb21wb25lbnRJZCIsImVycm9yIiwiY29uc29sZSIsInRyYW5zZm9ybWVyIiwic3RhdHVzIiwidmlkZW9zIiwicXVpekF0dGVtcHRzIiwicXVpelBhc3NlZCIsImJheUxpbmVzIiwiaXNvbGF0b3IiLCJjaXJjdWl0QnJlYWtlciIsInNhdmVQcm9ncmVzc1RvU3RvcmFnZSIsInByb2dyZXNzIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsIkNvdXJzZVByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzZXRQcm9ncmVzcyIsInVwZGF0ZVZpZGVvUHJvZ3Jlc3MiLCJ2aWRlb0lkIiwicHJvZ3Jlc3NWYWx1ZSIsInByZXYiLCJjb21wb25lbnQiLCJ2aWRlb0luZGV4IiwiZmluZEluZGV4IiwidiIsInB1c2giLCJ3YXRjaGVkIiwibWFya1ZpZGVvQ29tcGxldGUiLCJjb21wbGV0ZWRBdCIsIkRhdGUiLCJub3ciLCJzdWJtaXRRdWl6Iiwic2NvcmUiLCJwYXNzZWQiLCJxdWl6U2NvcmUiLCJxdWl6UGFzc2VkQXQiLCJpc1NpbXVsYXRpb25VbmxvY2tlZCIsInZhbHVlcyIsImV2ZXJ5IiwiY29tcCIsImdldE92ZXJhbGxQcm9ncmVzcyIsInRvdGFsQ29tcG9uZW50cyIsImxlbmd0aCIsImNvbXBsZXRlZENvbXBvbmVudHMiLCJmaWx0ZXIiLCJNYXRoIiwicm91bmQiLCJyZXNldFByb2dyZXNzIiwicmVtb3ZlSXRlbSIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VDb3Vyc2UiLCJjb250ZXh0IiwiRXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/course/course-context.tsx\n"));

/***/ })

});